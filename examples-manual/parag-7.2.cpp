
// example presented in paragraph 7.2 of the manual
// http://manifem.rd.ciencias.ulisboa.pt/manual-manifem.pdf
// mesh the flat torus RR2/ZZ2

#include "maniFEM.h"
using namespace maniFEM;


void print_segment ( Cell seg )

{	Manifold::Quotient * manif_q = dynamic_cast
		< Manifold::Quotient* > ( Manifold::working.core );
	assert ( manif_q );
	Function xy = manif_q->base_space.coordinates();
	Function x = xy[0], y = xy[1];
	size_t n = manif_q->actions.size();
	assert ( n == manif_q->spins.size() );
	Cell V = seg.base().reverse();
	Cell W = seg.tip();
	std::cout << "[(" << x(V) << "," << y(V) << "),(" << x(W) << "," <<y(W) << ")] ";
	Function::CompositionOfActions a = seg.spin();
	std::cout << "(";
	for ( size_t i = 0; i < n; i++ )
	{	Function::Action & g = manif_q->actions[i];
		std::map<Function::Action,short int>::const_iterator itt = a.index_map.find ( g );
		if ( itt == a.index_map.end() )
		{	std::cout << "0,"; continue;  }
		short int exp = itt->second;
		assert ( exp != 0 );
		std::cout << exp << ",";                                                            }
	std::cout << ")" << std::endl;                                                           }
	

int main ( )

{	// begin with the usual two-dimensional space
	Manifold RR2 ( tag::Euclid, tag::of_dim, 2 );
	Function xy = RR2.build_coordinate_system ( tag::Lagrange, tag::of_degree, 1 );
	Function x = xy[0], y = xy[1];

	// define two actions on RR2 (translations)
	Function::Action g1 ( tag::transforms, xy, tag::into, (x+1.) && y ),
	                 g2 ( tag::transforms, xy, tag::into, x && (y+1.) );

	// and divide RR2 by the group of translations generated by {g1,g2}
	Manifold torus_manif = RR2.quotient ( g1, g2 );

	// one vertex is enough to start the process
	Cell A ( tag::vertex );  x(A) = 0.02;  y(A) = 0.02;

	// with this vertex, we build two segments
	Mesh seg_horiz ( tag::segment, A.reverse(), A, tag::divided_in, 10, tag::spin, g1 ),
	     seg_vert  ( tag::segment, A.reverse(), A, tag::divided_in, 10, tag::spin, g2 );

	// two segments are enough to define a rectangle
	Mesh torus ( tag::rectangle,
               seg_horiz, seg_vert, seg_horiz.reverse(), seg_vert.reverse(),
	             tag::spin                                                    );
	// the tag::spin provides no specific information,
	// it just warns maniFEM that we are on a quotient manifold
	// and that it must take spins into account
	// specific information about spins is included in the two segments

	// it makes no sense to export 'torus' in msh format
	// we can build an unfolded mesh with no spins :
	// Mesh unfolded = torus.unfold();
	// unfolded.export_msh ("unfolded-torus.msh");
}
