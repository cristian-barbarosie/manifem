
// solve a celullar problem
// hexagonal periodicity, regular square elements


#include "maniFEM.h"
#include <Eigen/Sparse>
#include <Eigen/OrderingMethods>
using namespace maniFEM;

int main ( )

{	Manifold RR2 ( tag::Euclid, tag::of_dim, 2 );
	Function xy = RR2.build_coordinate_system ( tag::Lagrange, tag::of_degree, 1 );
	Function x = xy[0], y = xy[1];

	// define two actions on RR2 (translations)
	Function::Action g1 ( tag::transforms, xy, tag::into, (x+1.) && y ),
	                 g2 ( tag::transforms, xy, tag::into, (x+0.5) && (y+1.) );

	// and divide RR2 by the group of translations generated by {g1,g2}
	Manifold torus_manif = RR2.quotient ( g1, g2 );

	Cell A ( tag::vertex );  x(A) = 0. ;  y(A) = 0.;
	Cell B ( tag::vertex );  x(B) = 0.5;  y(B) = 0.;

	Mesh AB ( tag::segment, A.reverse(), B, tag::divided_in, 5 );
	Mesh BA1 ( tag::segment, B.reverse(), A, tag::divided_in, 5, tag::spin, g1 );
	Mesh BA2 ( tag::segment, B.reverse(), A, tag::divided_in, 10, tag::spin, g2 );
	Mesh AB2 ( tag::segment, A.reverse(), B, tag::divided_in, 10, tag::spin, g2 - g1 );

	Mesh sq1 ( tag::rectangle, AB, BA2, BA1.reverse(), AB2.reverse(), tag::spin );
	Mesh sq2 ( tag::rectangle, BA2.reverse(), BA1, AB2, AB.reverse(), tag::spin );
	Mesh torus ( tag::join, sq1, sq2 );

	std::vector < Cell > vec;
	{ // just a block of code for hiding 'it'
	CellIterator it = torus.iterator ( tag::over_cells, tag::of_dim, 2, tag::around, B );
	for ( it.reset(); it.in_range(); it++ )
		vec.push_back ( *it );
	std::vector<Cell>::iterator itv;
	for ( itv = vec.begin(); itv != vec.end(); itv++ )
	{	Cell sq = *itv;  sq.remove_from_mesh ( torus );  }
	} // just a block of code for hiding 'it'

	// declare the type of finite element
	FiniteElement fe ( tag::with_master, tag::quadrangle, tag::Lagrange, tag::of_degree, 1 );
	Integrator integ = fe.set_integrator ( tag::Gauss, tag::quad_9 );

	std::map < Cell, size_t > numbering;
	{ // just a block of code for hiding 'it' and 'counter'
	CellIterator it = torus.iterator ( tag::over_vertices );
	size_t counter = 0;
	for ( it.reset() ; it.in_range(); it++ )
	{	Cell V = *it;  numbering[V] = counter;  ++counter;  }
	assert ( counter == numbering.size() );
	} // just a block of code

	size_t size_matrix = numbering.size();
	std::cout << "global matrix " << size_matrix + 1 << "x" << size_matrix << std::endl;
	Eigen::SparseMatrix < double > matrix_A ( size_matrix + 1, size_matrix );
	
	matrix_A.reserve ( Eigen::VectorXi::Constant ( size_matrix, 10 ) );

	Eigen::VectorXd vector_b ( size_matrix + 1 ), vector_sol ( size_matrix );
	vector_b.setZero();

	xy = Manifold::working.coordinates();
	x = xy[0];  y = xy[1];

	// macroscopic temperature gradient
	//	std::map < Function::Action, double > jump_of_solution = x.jump();

	// run over all square cells composing 'torus'
	{ // just a block of code for hiding 'it'
	CellIterator it = torus.iterator ( tag::over_cells_of_max_dim );
	for ( it.reset(); it.in_range(); it++ )
	{	Cell small_tri = *it;
		std::cout << "******************" << std::endl;
		fe.dock_on ( small_tri, tag::spin );
		// run twice over the four vertices of 'small_tri'
		CellIterator it_V = small_tri.boundary().iterator ( tag::over_vertices );
		for ( it_V.reset(); it_V.in_range(); it_V++ )
		{	Cell V = *it_V;
			// perhaps implement an interator returning a vertex and a segment
			Cell seg = small_tri .boundary(). cell_in_front_of ( V );
			Cell W = V;
			double jump_V_W = 0.;
			while ( true )
			{	assert ( W == seg.base().reverse() );
				// V may be the same as W, no problem about that
				Function psi_V = fe .basis_function ( V ),
				         psi_W = fe .basis_function ( W ),
				         d_psi_V_dx = psi_V .deriv ( x ),
				         d_psi_V_dy = psi_V .deriv ( y ),
				         d_psi_W_dx = psi_W .deriv ( x ),
				         d_psi_W_dy = psi_W .deriv ( y );
				// 'fe' is already docked on 'small_tri' so this will be the domain of integration
				double integral = fe.integrate ( d_psi_V_dx * d_psi_W_dx + d_psi_V_dy * d_psi_W_dy );
				matrix_A.coeffRef ( numbering[V], numbering[W] ) += integral;
				//		vector_b ( numbering[V] ) -= jump_V_W * integral;
				//		jump_V_W += jump_of_solution [ seg.spin() ];
				W = seg.tip();
				if ( V == W ) break;
				seg = small_tri .boundary() .cell_in_front_of ( seg.tip() );                          }
			// here  jump_V_W  should be zero again
			// but we do not assert that, rounding errors may mess up things
		}  }
	} // just a block of code for hiding 'it'
	
}
